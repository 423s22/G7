import React$1, { useRef, useState, useCallback, useMemo, useEffect } from 'react';
import debounce$1 from 'lodash/debounce';
import { EventListener as EventListener$1 } from '../EventListener/EventListener.tsx.esnext';
import { useI18n } from '../../utilities/i18n/hooks.tsx.esnext';
import { durationFast } from '@shopify/polaris-tokens';
import { classNames } from '../../utilities/css.ts.esnext';
import { EnableSelectionMinor } from '@shopify/polaris-icons';
import { VisuallyHidden as VisuallyHidden$1 } from '../VisuallyHidden/VisuallyHidden.tsx.esnext';
import { Spinner as Spinner$1 } from '../Spinner/Spinner.tsx.esnext';
import { Badge as Badge$1 } from '../Badge/Badge.tsx.esnext';
import { Button as Button$1 } from '../Button/Button.tsx.esnext';
import { useToggle as useToggle$1 } from '../../utilities/use-toggle.ts.esnext';
import { Stack as Stack$1 } from '../Stack/Stack.tsx.esnext';
import { CSSTransition } from 'react-transition-group';
import { Checkbox as Checkbox$1 } from '../Checkbox/Checkbox.tsx.esnext';
import { BulkActions as BulkActions$1 } from '../BulkActions/BulkActions.tsx.esnext';
import { EmptySearchResult as EmptySearchResult$1 } from '../EmptySearchResult/EmptySearchResult.tsx.esnext';
import styles from './IndexTable.scss.esnext';
import { Cell as Cell$1 } from './components/Cell/Cell.tsx.esnext';
import { SELECT_ALL_ITEMS, SelectionType } from '../../utilities/index-provider/types.ts.esnext';
import { useIndexValue, useIndexSelectionChange } from '../../utilities/index-provider/hooks.ts.esnext';
import { Row as Row$1 } from './components/Row/Row.tsx.esnext';
import { ScrollContainer as ScrollContainer$1 } from './components/ScrollContainer/ScrollContainer.tsx.esnext';
import { Sticky as Sticky$1 } from '../Sticky/Sticky.tsx.esnext';
import { AfterInitialMount as AfterInitialMount$1 } from '../AfterInitialMount/AfterInitialMount.tsx.esnext';
import { IndexProvider as IndexProvider$1 } from '../IndexProvider/IndexProvider.tsx.esnext';
import { getTableHeadingsBySelector } from './utilities/utilities.ts.esnext';

const SCROLL_BAR_PADDING = 4;
const SIXTY_FPS = 1000 / 60;
const SCROLL_BAR_DEBOUNCE_PERIOD = 300;
const SMALL_SCREEN_WIDTH = 458;

var _ref = /*#__PURE__*/React$1.createElement(Spinner$1, {
  size: "small"
});

function IndexTableBase({
  headings,
  bulkActions = [],
  promotedBulkActions = [],
  children,
  emptyState,
  sort
}) {
  const {
    loading,
    bulkSelectState,
    resourceName,
    bulkActionsAccessibilityLabel,
    selectMode,
    paginatedSelectAllText,
    itemCount,
    hasMoreItems,
    selectedItemsCount,
    condensed
  } = useIndexValue();
  const handleSelectionChange = useIndexSelectionChange();
  const i18n = useI18n();
  const {
    value: hasMoreLeftColumns,
    toggle: toggleHasMoreLeftColumns
  } = useToggle$1(false);
  const onboardingScrollButtons = useRef(false);
  const tablePosition = useRef({
    top: 0,
    left: 0
  });
  const tableHeadingRects = useRef([]);
  const scrollableContainerElement = useRef(null);
  const tableElement = useRef(null);
  const [tableInitialized, setTableInitialized] = useState(false);
  const [isSmallScreenSelectable, setIsSmallScreenSelectable] = useState(false);
  const tableHeadings = useRef([]);
  const stickyTableHeadings = useRef([]);
  const stickyHeaderWrapperElement = useRef(null);
  const stickyHeaderCheckboxElement = useRef(null);
  const stickyHeaderElement = useRef(null);
  const scrollBarElement = useRef(null);
  const scrollingWithBar = useRef(false);
  const scrollingContainer = useRef(false);
  const tableBodyRef = useCallback(node => {
    if (node !== null && !tableInitialized) {
      setTableInitialized(true);
    }
  }, [tableInitialized]);
  const toggleIsSmallScreenSelectable = useCallback(() => {
    setIsSmallScreenSelectable(value => !value);
  }, []);
  const handleSelectAllItemsInStore = useCallback(() => {
    handleSelectionChange(selectedItemsCount === SELECT_ALL_ITEMS ? SelectionType.Page : SelectionType.All, true);
  }, [handleSelectionChange, selectedItemsCount]);
  const calculateFirstHeaderOffset = useCallback(() => {
    return condensed ? tableHeadingRects.current[0].offsetWidth : tableHeadingRects.current[0].offsetWidth + tableHeadingRects.current[1].offsetWidth;
  }, [condensed]);
  const resizeTableHeadings = useMemo(() => debounce$1(() => {
    if (!tableElement.current || !scrollableContainerElement.current) {
      return;
    }

    const boundingRect = scrollableContainerElement.current.getBoundingClientRect();
    tablePosition.current = {
      top: boundingRect.top,
      left: boundingRect.left
    };
    tableHeadingRects.current = tableHeadings.current.map(heading => ({
      offsetWidth: heading.offsetWidth || 0,
      offsetLeft: heading.offsetLeft || 0
    }));

    if (tableHeadings.current.length === 0) {
      return;
    } // update left offset for first column


    if (tableHeadings.current.length > 1) tableHeadings.current[1].style.left = `${tableHeadingRects.current[0].offsetWidth}px`; // update the min width of the checkbox to be the be the un-padded width of the first heading

    if (stickyHeaderCheckboxElement == null ? void 0 : stickyHeaderCheckboxElement.current) {
      const elementStyle = getComputedStyle(tableHeadings.current[0]);
      const boxWidth = tableHeadings.current[0].offsetWidth;
      stickyHeaderCheckboxElement.current.style.minWidth = `calc(${boxWidth}px - ${elementStyle.paddingLeft} - ${elementStyle.paddingRight} + 2px)`;
    } // update sticky header min-widths


    stickyTableHeadings.current.forEach((heading, index) => {
      let minWidth = 0;

      if (index === 0 && !isSmallScreen()) {
        minWidth = calculateFirstHeaderOffset();
      } else if (tableHeadingRects.current.length > index) {
        minWidth = tableHeadingRects.current[index].offsetWidth;
      }

      heading.style.minWidth = `${minWidth}px`;
    });
  }, SIXTY_FPS, {
    leading: true,
    trailing: true,
    maxWait: SIXTY_FPS
  }), [calculateFirstHeaderOffset]);
  const resizeTableScrollBar = useCallback(() => {
    if (scrollBarElement.current && tableElement.current && tableInitialized) {
      scrollBarElement.current.style.setProperty('--p-scroll-bar-content-width', `${tableElement.current.offsetWidth - SCROLL_BAR_PADDING}px`);
    }
  }, [tableInitialized]); // eslint-disable-next-line react-hooks/exhaustive-deps

  const debounceResizeTableScrollbar = useCallback(debounce$1(resizeTableScrollBar, SCROLL_BAR_DEBOUNCE_PERIOD, {
    trailing: true
  }), [resizeTableScrollBar]);
  const handleResize = useCallback(() => {
    var _scrollBarElement$cur;

    // hide the scrollbar when resizing
    (_scrollBarElement$cur = scrollBarElement.current) == null ? void 0 : _scrollBarElement$cur.style.setProperty('--p-scroll-bar-content-width', `0px`);
    resizeTableHeadings();
    debounceResizeTableScrollbar();
  }, [debounceResizeTableScrollbar, resizeTableHeadings]);
  const handleScrollContainerScroll = useCallback((canScrollLeft, canScrollRight) => {
    if (!scrollableContainerElement.current || !scrollBarElement.current) {
      return;
    }

    if (!scrollingWithBar.current) {
      scrollingContainer.current = true;
      scrollBarElement.current.scrollLeft = scrollableContainerElement.current.scrollLeft;
    }

    scrollingWithBar.current = false;

    if (stickyHeaderElement.current) {
      stickyHeaderElement.current.scrollLeft = scrollableContainerElement.current.scrollLeft;
    }

    if (canScrollLeft && !hasMoreLeftColumns || !canScrollLeft && hasMoreLeftColumns) {
      toggleHasMoreLeftColumns();
    }

    if (!canScrollRight) {
      onboardingScrollButtons.current = false;
    }
  }, [hasMoreLeftColumns, toggleHasMoreLeftColumns]);
  const handleScrollBarScroll = useCallback(() => {
    if (!scrollableContainerElement.current || !scrollBarElement.current) {
      return;
    }

    if (!scrollingContainer.current) {
      scrollingWithBar.current = true;
      scrollableContainerElement.current.scrollLeft = scrollBarElement.current.scrollLeft;
    }

    scrollingContainer.current = false;
  }, []);
  useEffect(() => {
    tableHeadings.current = getTableHeadingsBySelector(tableElement.current, '[data-index-table-heading]');
    stickyTableHeadings.current = getTableHeadingsBySelector(stickyHeaderWrapperElement.current, '[data-index-table-sticky-heading]');
    resizeTableHeadings();
  }, [headings, resizeTableHeadings, stickyHeaderCheckboxElement, tableInitialized]);
  useEffect(() => {
    resizeTableScrollBar();
  }, [tableInitialized, resizeTableScrollBar]);
  useEffect(() => {
    if (!condensed && isSmallScreenSelectable) {
      setIsSmallScreenSelectable(false);
    }
  }, [condensed, isSmallScreenSelectable]);
  const selectable = Boolean(promotedBulkActions && promotedBulkActions.length > 0 || bulkActions && bulkActions.length > 0);
  const headingsMarkup = headings.map(renderHeading).reduce((acc, heading) => acc.concat(heading), []);
  const bulkActionsSelectable = Boolean(promotedBulkActions.length > 0 || bulkActions.length > 0);
  const stickyColumnHeaderStyle = tableHeadingRects.current && tableHeadingRects.current.length > 0 ? {
    minWidth: calculateFirstHeaderOffset()
  } : undefined;
  const stickyColumnHeader = /*#__PURE__*/React$1.createElement("div", {
    className: styles.TableHeading,
    key: headings[0].title,
    style: stickyColumnHeaderStyle,
    "data-index-table-sticky-heading": true
  }, /*#__PURE__*/React$1.createElement(Stack$1, {
    spacing: "none",
    wrap: false,
    alignment: "center"
  }, /*#__PURE__*/React$1.createElement("div", {
    className: styles.StickyColumnHeaderCheckbox,
    ref: stickyHeaderCheckboxElement
  }, renderCheckboxContent()), /*#__PURE__*/React$1.createElement("div", {
    className: styles['StickyTableHeading-second-scrolling']
  }, renderHeadingContent(headings[0]))));
  const stickyHeadingsMarkup = headings.map(renderStickyHeading);
  const selectedItemsCountLabel = selectedItemsCount === SELECT_ALL_ITEMS ? `${itemCount}+` : selectedItemsCount;
  const handleTogglePage = useCallback(() => {
    handleSelectionChange(SelectionType.Page, Boolean(!bulkSelectState || bulkSelectState === 'indeterminate'));
  }, [bulkSelectState, handleSelectionChange]);
  const paginatedSelectAllAction = getPaginatedSelectAllAction();
  const loadingTransitionClassNames = {
    enter: styles['LoadingContainer-enter'],
    enterActive: styles['LoadingContainer-enter-active'],
    exit: styles['LoadingContainer-exit'],
    exitActive: styles['LoadingContainer-exit-active']
  };
  const loadingMarkup = /*#__PURE__*/React$1.createElement(CSSTransition, {
    in: loading,
    classNames: loadingTransitionClassNames,
    timeout: durationFast,
    appear: true,
    unmountOnExit: true
  }, /*#__PURE__*/React$1.createElement("div", {
    className: styles.LoadingPanel
  }, /*#__PURE__*/React$1.createElement("div", {
    className: styles.LoadingPanelRow
  }, _ref, /*#__PURE__*/React$1.createElement("span", {
    className: styles.LoadingPanelText
  }, i18n.translate('Polaris.IndexTable.resourceLoadingAccessibilityLabel', {
    resourceNamePlural: resourceName.plural.toLocaleLowerCase()
  })))));
  const stickyTableClassNames = classNames(styles.StickyTable, condensed && styles['StickyTable-condensed']);
  const shouldShowBulkActions = bulkActionsSelectable && selectedItemsCount || isSmallScreenSelectable;
  const stickyHeaderMarkup = /*#__PURE__*/React$1.createElement("div", {
    className: stickyTableClassNames,
    role: "presentation"
  }, /*#__PURE__*/React$1.createElement(Sticky$1, null, isSticky => {
    const stickyHeaderClassNames = classNames(styles.StickyTableHeader, isSticky && styles['StickyTableHeader-isSticky']);
    const bulkActionClassNames = classNames(styles.BulkActionsWrapper, condensed && styles['StickyTableHeader-condensed'], isSticky && styles['StickyTableHeader-isSticky']);
    const shouldShowActions = !condensed || selectedItemsCount;
    const promotedActions = shouldShowActions ? promotedBulkActions : [];
    const actions = shouldShowActions ? bulkActions : [];
    const bulkActionsMarkup = shouldShowBulkActions ? /*#__PURE__*/React$1.createElement("div", {
      className: bulkActionClassNames,
      "data-condensed": condensed
    }, loadingMarkup, /*#__PURE__*/React$1.createElement(BulkActions$1, {
      smallScreen: condensed,
      label: i18n.translate('Polaris.IndexTable.selected', {
        selectedItemsCount: selectedItemsCountLabel
      }),
      accessibilityLabel: bulkActionsAccessibilityLabel,
      selected: bulkSelectState,
      selectMode: selectMode || isSmallScreenSelectable,
      onToggleAll: handleTogglePage,
      promotedActions: promotedActions,
      actions: actions,
      paginatedSelectAllText: paginatedSelectAllText,
      paginatedSelectAllAction: paginatedSelectAllAction,
      onSelectModeToggle: condensed ? handleSelectModeToggle : undefined
    })) : null;
    const stickyColumnHeaderClassNames = classNames(styles.StickyTableColumnHeader, hasMoreLeftColumns && styles['StickyTableColumnHeader-isScrolling']);
    const headerMarkup = condensed ? /*#__PURE__*/React$1.createElement("div", {
      className: styles.HeaderWrapper
    }, loadingMarkup, sort, /*#__PURE__*/React$1.createElement(Button$1, {
      icon: EnableSelectionMinor,
      onClick: toggleIsSmallScreenSelectable
    }, i18n.translate('Polaris.IndexTable.selectButtonText'))) : /*#__PURE__*/React$1.createElement("div", {
      className: stickyHeaderClassNames,
      ref: stickyHeaderWrapperElement
    }, loadingMarkup, /*#__PURE__*/React$1.createElement("div", {
      className: stickyColumnHeaderClassNames
    }, stickyColumnHeader), /*#__PURE__*/React$1.createElement("div", {
      className: styles.StickyTableHeadings,
      ref: stickyHeaderElement
    }, stickyHeadingsMarkup));
    const stickyContent = bulkActionsMarkup ? bulkActionsMarkup : headerMarkup;
    return stickyContent;
  }));
  const scrollBarWrapperClassNames = classNames(styles.ScrollBarContainer, condensed && styles.scrollBarContainerCondensed);
  const scrollBarClassNames = classNames(tableElement.current && tableInitialized && styles.ScrollBarContent);
  const scrollBarMarkup = itemCount > 0 ? /*#__PURE__*/React$1.createElement(AfterInitialMount$1, null, /*#__PURE__*/React$1.createElement("div", {
    className: scrollBarWrapperClassNames
  }, /*#__PURE__*/React$1.createElement("div", {
    onScroll: handleScrollBarScroll,
    className: styles.ScrollBar,
    ref: scrollBarElement
  }, /*#__PURE__*/React$1.createElement("div", {
    className: scrollBarClassNames
  })))) : null;
  const tableClassNames = classNames(styles.Table, hasMoreLeftColumns && styles['Table-scrolling'], selectMode && styles.disableTextSelection, selectMode && shouldShowBulkActions && styles.selectMode);
  const emptyStateMarkup = emptyState ? emptyState : /*#__PURE__*/React$1.createElement(EmptySearchResult$1, {
    title: i18n.translate('Polaris.IndexTable.emptySearchTitle', {
      resourceNamePlural: resourceName.plural
    }),
    description: i18n.translate('Polaris.IndexTable.emptySearchDescription'),
    withIllustration: true
  });
  const sharedMarkup = /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/React$1.createElement(EventListener$1, {
    event: "resize",
    handler: handleResize
  }), /*#__PURE__*/React$1.createElement(AfterInitialMount$1, null, stickyHeaderMarkup));
  const bodyMarkup = condensed ? /*#__PURE__*/React$1.createElement(React$1.Fragment, null, sharedMarkup, /*#__PURE__*/React$1.createElement("ul", {
    "data-selectmode": Boolean(selectMode || isSmallScreenSelectable),
    className: styles.CondensedList
  }, children)) : /*#__PURE__*/React$1.createElement(React$1.Fragment, null, sharedMarkup, /*#__PURE__*/React$1.createElement(ScrollContainer$1, {
    scrollableContainerRef: scrollableContainerElement,
    onScroll: handleScrollContainerScroll
  }, /*#__PURE__*/React$1.createElement("table", {
    ref: tableElement,
    className: tableClassNames
  }, /*#__PURE__*/React$1.createElement("thead", null, /*#__PURE__*/React$1.createElement("tr", {
    className: styles.HeadingRow
  }, headingsMarkup)), /*#__PURE__*/React$1.createElement("tbody", {
    ref: tableBodyRef
  }, children))));
  const tableContentMarkup = itemCount > 0 ? bodyMarkup : /*#__PURE__*/React$1.createElement("div", {
    className: styles.EmptySearchResultWrapper
  }, emptyStateMarkup);
  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/React$1.createElement("div", {
    className: styles.IndexTable
  }, !shouldShowBulkActions && !condensed && loadingMarkup, tableContentMarkup), scrollBarMarkup);

  function renderHeading(heading, index) {
    const isSecond = index === 0;
    const headingContentClassName = classNames(styles.TableHeading, isSecond && styles['TableHeading-second']);
    const stickyPositioningStyle = isSecond && tableHeadingRects.current && tableHeadingRects.current.length > 0 ? {
      left: tableHeadingRects.current[0].offsetWidth
    } : undefined;
    const headingContent = /*#__PURE__*/React$1.createElement("th", {
      className: headingContentClassName,
      key: heading.title,
      "data-index-table-heading": true,
      style: stickyPositioningStyle
    }, renderHeadingContent(heading));
    if (index !== 0) return headingContent;
    const checkboxClassName = classNames(styles.TableHeading, index === 0 && styles['TableHeading-first']);
    const checkboxContent = /*#__PURE__*/React$1.createElement("th", {
      className: checkboxClassName,
      key: `${heading}-${index}`,
      "data-index-table-heading": true
    }, renderCheckboxContent());
    return [checkboxContent, headingContent];
  }

  function renderCheckboxContent() {
    return /*#__PURE__*/React$1.createElement("div", {
      className: styles.ColumnHeaderCheckboxWrapper
    }, /*#__PURE__*/React$1.createElement(Checkbox$1, {
      label: i18n.translate('Polaris.IndexTable.selectAllLabel', {
        resourceNamePlural: resourceName.plural
      }),
      labelHidden: true,
      onChange: handleSelectPage,
      checked: bulkSelectState
    }));
  }

  function renderHeadingContent(heading) {
    let headingContent;

    if (heading.new) {
      headingContent = /*#__PURE__*/React$1.createElement(Stack$1, {
        wrap: false,
        alignment: "center"
      }, /*#__PURE__*/React$1.createElement("span", null, heading.title), /*#__PURE__*/React$1.createElement(Badge$1, {
        status: "new"
      }, i18n.translate('Polaris.IndexTable.onboardingBadgeText')));
    } else if (heading.hidden) {
      headingContent = /*#__PURE__*/React$1.createElement(VisuallyHidden$1, null, heading.title);
    } else {
      headingContent = heading.title;
    }

    return headingContent;
  }

  function handleSelectPage(checked) {
    handleSelectionChange(SelectionType.Page, checked);
  }

  function renderStickyHeading(heading, index) {
    const position = index + 1;
    const headingStyle = tableHeadingRects.current && tableHeadingRects.current.length > position ? {
      minWidth: tableHeadingRects.current[position].offsetWidth
    } : undefined;
    const headingContent = renderHeadingContent(heading);
    const stickyHeadingClassName = classNames(styles.TableHeading, index === 0 && styles['StickyTableHeading-second']);
    return /*#__PURE__*/React$1.createElement("div", {
      className: stickyHeadingClassName,
      key: heading.title,
      style: headingStyle,
      "data-index-table-sticky-heading": true
    }, headingContent);
  }

  function getPaginatedSelectAllAction() {
    if (!selectable || !hasMoreItems) {
      return;
    }

    const actionText = selectedItemsCount === SELECT_ALL_ITEMS ? i18n.translate('Polaris.IndexTable.undo') : i18n.translate('Polaris.IndexTable.selectAllItems', {
      itemsLength: itemCount,
      resourceNamePlural: resourceName.plural.toLocaleLowerCase()
    });
    return {
      content: actionText,
      onAction: handleSelectAllItemsInStore
    };
  }

  function handleSelectModeToggle(val) {
    handleSelectionChange(SelectionType.All, false);
    setIsSmallScreenSelectable(val);
  }
}

const isSmallScreen = () => {
  return typeof window === 'undefined' ? false : window.innerWidth < SMALL_SCREEN_WIDTH;
};

function IndexTable({
  children,
  selectable,
  itemCount,
  selectedItemsCount,
  resourceName: passedResourceName,
  loading,
  hasMoreItems,
  condensed,
  onSelectionChange,
  ...indexTableBaseProps
}) {
  return /*#__PURE__*/React$1.createElement(IndexProvider$1, {
    selectable: selectable,
    itemCount: itemCount,
    selectedItemsCount: selectedItemsCount,
    resourceName: passedResourceName,
    loading: loading,
    hasMoreItems: hasMoreItems,
    condensed: condensed,
    onSelectionChange: onSelectionChange
  }, /*#__PURE__*/React$1.createElement(IndexTableBase, indexTableBaseProps, children));
}
IndexTable.Cell = Cell$1;
IndexTable.Row = Row$1;

export { IndexTable };
